---
{"dg-publish":true,"permalink":"/network/http/"}
---

## 简述 HTTP1.0/1.1/2.0 的区别

### HTTP 1.0

HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。

- HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。
    
- HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。
    
- HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。
    
- HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。
    
- HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。
    

### HTTP 1.1

HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化

- HTTP 1.1 使用了摘要算法来进行身份验证
    
- HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 `keep-alive` 来设置
    
- HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。
    
- HTTP 1.1 支持断点续传，通过使用请求头中的 `Range` 来实现。
    
- HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
    

### HTTP 2.0

HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下

- `头部压缩`，由于 HTTP 1.1 经常会出现 **User-Agent、Cookie、Accept、Server、Range** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 `HPACK` 算法进行压缩。
    
- `二进制格式`，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率
    
- `强化安全`，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。
    
- `多路复用`，即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。


## HTTPS 的工作原理

我们探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。

TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。

每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。

TLS 具体的握手过程会根据所使用的`密钥交换算法的类型`和双方支持的`密码套件`而不同。我们以`RSA 非对称加密`来讨论这个过程。整个 TLS 通信流程图如下

![](https://pic.imgdb.cn/item/6572950fc458853aef4ea92b.png)

- 在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程
    
- ClientHello：客户端通过向服务器发送 `hello` 消息来发起握手过程。这个消息中会夹带着客户端支持的 `TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)` 、客户端支持的密码套件、以及一串 `客户端随机数`。
    
- ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。
    
- 认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 `Certificate` 报文，报文中包含公开密钥证书。最后服务器发送 `ServerHelloDone` 作为 `hello` 请求的响应。第一部分握手阶段结束。
    
- `加密阶段`：在第一个阶段握手完成后，客户端会发送 `ClientKeyExchange` 作为响应，这个响应中包含了一种称为 `The premaster secret` 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 `ChangeCipherSpec`，告诉服务端使用私钥解密这个 `premaster secret` 的字符串，然后客户端发送 `Finished` 告诉服务端自己发送完成了。
    

> Session key 其实就是用公钥证书加密的公钥。

- `实现了安全的非对称加密`：然后，服务器再发送 `ChangeCipherSpec` 和 `Finished` 告诉客户端解密完成，至此实现了 RSA 的非对称加密。


## 对称加密

对称加密（Symmetric Encryption）是一种加密方法，在这种方法中，发送方和接收方使用相同的密钥来加密和解密信息。对称加密算法的主要特点是速度快、效率高，适用于大规模数据加密。对称加密的常见算法包括AES（高级加密标准）、DES（数据加密标准）、3DES（三重数据加密标准）和RC4等。

对称加密的工作原理可以概括如下：
1. **密钥生成**：发送方和接收方共享一个密钥。密钥的安全性非常重要，因为任何获取到密钥的第三方都可以解密被加密的数据。
2. **加密过程**：发送方使用共享密钥和加密算法对明文数据进行加密，生成密文。
3. **传输密文**：加密后的密文通过不安全的信道传输到接收方。
4. **解密过程**：接收方使用相同的共享密钥和加密算法对密文进行解密，还原出原始的明文数据。

### 对称加密的优缺点

**优点**：
1. **速度快**：对称加密算法一般比非对称加密算法快，因此适用于大量数据的加密。
2. **实现简单**：对称加密算法相对简单，易于实现和使用。

**缺点**：
1. **密钥管理难度大**：共享密钥需要在发送方和接收方之间安全地分发和管理，如果密钥被泄露，通信的安全性将受到严重威胁。
2. **无法提供数字签名功能**：对称加密无法实现不可否认性（non-repudiation），因为发送方和接收方都使用相同的密钥，无法区分谁进行了加密操作。

### 常见的对称加密算法

1. **AES（Advanced Encryption Standard）**：AES是目前应用最广泛的对称加密算法，具有128位、192位和256位密钥长度，安全性高且效率高。
2. **DES（Data Encryption Standard）**：DES是一种较早期的对称加密算法，使用56位密钥，现已被认为不够安全，逐渐被AES替代。
3. **3DES（Triple DES）**：3DES通过对数据进行三次DES加密，提高了安全性，但效率较低。
4. **RC4**：一种流加密算法，速度快，但由于存在安全漏洞，逐渐被其他算法取代。

### 应用场景

对称加密广泛应用于需要高效加密的场景，如文件加密、磁盘加密、虚拟专用网（VPN）等。在实际应用中，通常会结合非对称加密（如RSA）进行密钥交换，以确保密钥的安全分发和管理，从而充分发挥对称加密的优势。

总之，对称加密在现代信息安全中起着重要作用，其高效性和易实现性使其在各种安全通信和数据保护场景中得到了广泛应用。


## 非对称加密

非对称加密（Asymmetric Encryption），也称为公钥加密，是一种加密方法，其中使用成对的密钥进行加密和解密：公钥和私钥。公钥用于加密数据，而私钥用于解密数据。由于这两个密钥是数学上相关联的，一方使用公钥加密的信息只能由对应的私钥解密，反之亦然。常见的非对称加密算法包括RSA、ECC（椭圆曲线加密）、DSA（数字签名算法）等。

### 非对称加密的工作原理

1. **密钥生成**：生成一对密钥，包括公钥和私钥。公钥可以公开分发，而私钥必须保密。
2. **加密过程**：
   - 发送方使用接收方的公钥对信息进行加密，生成密文。
3. **传输密文**：加密后的密文通过不安全的信道传输给接收方。
4. **解密过程**：
   - 接收方使用自己的私钥对密文进行解密，还原出原始的明文数据。

### 非对称加密的优缺点

**优点**：
1. **密钥管理更安全**：公钥可以公开分发，而私钥无需共享，从而降低了密钥泄露的风险。
2. **支持数字签名**：非对称加密可以实现不可否认性（non-repudiation），发送方可以用私钥对信息签名，接收方使用公钥验证签名，从而确认信息确实来自发送方。
3. **安全性高**：非对称加密算法基于复杂的数学问题，如大整数分解和离散对数问题，具有较高的安全性。

**缺点**：
1. **速度慢**：与对称加密相比，非对称加密算法的计算复杂度高，因此加密和解密速度较慢，不适合大规模数据加密。
2. **实现复杂**：非对称加密算法相对复杂，实现和使用上更为困难。

### 常见的非对称加密算法

1. **RSA（Rivest-Shamir-Adleman）**：基于大整数分解问题，广泛应用于安全通信和数字签名。
2. **ECC（Elliptic Curve Cryptography）**：基于椭圆曲线离散对数问题，相对于RSA，ECC提供了更高的安全性和更低的计算复杂度，使用更小的密钥可以实现相同的安全强度。
3. **DSA（Digital Signature Algorithm）**：主要用于数字签名，基于离散对数问题。

### 应用场景

非对称加密广泛应用于需要高安全性和密钥管理方便的场景，如：
- **数字证书**：通过CA（证书颁发机构）签发的数字证书，用于验证服务器和客户端的身份。
- **安全通信**：如HTTPS协议，通过SSL/TLS协议实现安全的数据传输。
- **数字签名**：确保信息的完整性和真实性，用于电子邮件签名、软件分发等场景。

### 综合使用

在实际应用中，非对称加密通常与对称加密结合使用。例如，在SSL/TLS协议中，使用非对称加密进行密钥交换，随后使用对称加密进行数据传输，这样既保证了密钥交换的安全性，又提高了数据传输的效率。

总之，非对称加密在现代信息安全中具有不可替代的重要作用，特别是在密钥管理和数字签名等方面，其高安全性和灵活性使其成为很多安全协议和系统的核心组成部分。